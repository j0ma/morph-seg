#!/bin/bash

# Created by argbash-init v2.8.1
# ARG_OPTIONAL_SINGLE([sentences])
# ARG_OPTIONAL_SINGLE([morsel-segmentations])
# ARG_OPTIONAL_SINGLE([bpe-codes])
# ARG_OPTIONAL_SINGLE([output-file])
# ARG_HELP([<The general help message of my script>])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die() {
    local _ret=$2
    test -n "$_ret" || _ret=1
    test "$_PRINT_HELP" = yes && print_help >&2
    echo "$1" >&2
    exit ${_ret}
}

begins_with_short_option() {
    local first_option all_short_options='h'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
#_arg_sentences=
_arg_morsel_segmentations="./morsel_seg_bpe_map.txt"
_arg_bpe_codes="./stem_code.txt"
#_arg_output_file=

print_help() {
    printf '%s\n' "<The general help message of my script>"
    printf 'Usage: %s [--sentences <arg>] [--morsel-segmentations <arg>] [--bpe-codes <arg>] [--output-file <arg>] [-h|--help]\n' "$0"
    printf '\t%s\n' "-h, --help: Prints help"
}

parse_commandline() {
    while test $# -gt 0; do
        _key="$1"
        case "$_key" in
        --sentences)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_sentences="$2"
            shift
            ;;
        --sentences=*)
            _arg_sentences="${_key##--sentences=}"
            ;;
        --morsel-segmentations)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_morsel_segmentations="$2"
            shift
            ;;
        --morsel-segmentations=*)
            _arg_morsel_segmentations="${_key##--morsel-segmentations=}"
            ;;
        --bpe-codes)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_bpe_codes="$2"
            shift
            ;;
        --bpe-codes=*)
            _arg_bpe_codes="${_key##--bpe-codes=}"
            ;;
        --output-file)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_output_file="$2"
            shift
            ;;
        --output-file=*)
            _arg_output_file="${_key##--output-file=}"
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        -h*)
            print_help
            exit 0
            ;;
        *)
            _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
            ;;
        esac
        shift
    done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

printf 'Value of --%s: %s\n' 'sentences' "$_arg_sentences"
printf 'Value of --%s: %s\n' 'morsel-segmentations' "$_arg_morsel_segmentations"
printf 'Value of --%s: %s\n' 'bpe-codes' "$_arg_bpe_codes"
printf 'Value of --%s: %s\n' 'output-file' "$_arg_output_file"

SENTENCES="${_arg_sentences}"
SENTENCES_FNAME=$(basename "${SENTENCES}")
PYTHON_SEGM_SCRIPT="./src/segment_sentences_morsel.py"
SEGM_BPE_MAP="${_arg_morsel_segmentations}"
SEGM_BPE_MAP_FNAME=$(basename "${SEGM_BPE_MAP}")
SEGM_BPE_MAP_SORTED="/tmp/morsel_seg_bpe_map.txt.sorted"
SEGM_VOCAB="/tmp/${SEGM_BPE_MAP_FNAME}.vocab"
STEM_CODES="${_arg_bpe_codes}"
VOCAB_TOT="/tmp/${SENTENCES_FNAME}.vocab.tot"
VOCAB_IV="/tmp/${SENTENCES_FNAME}.vocab.iv"
VOCAB_OOV="/tmp/${SENTENCES_FNAME}.vocab.oov"

# list of different vocab files
#  1.) supported vocab from seg2bpe map
#  2.) total vocab from sentences
#  3.) in-vocab from sentences (intersection of first 2 above)
#  4.) OOV from training data (3. - 2.)

# note: this script will be applied separately to
#       train/valid/test data. obviously all train
#       data will be in-vocabulary, but valid/test
#       will most likely contain some OOV tokens.

# step 0: create segmentation-supported vocab
sort -k 1,1 <"${SEGM_BPE_MAP}" >"${SEGM_BPE_MAP_SORTED}"

echo "Creating segmentation-supported vocab..."
cut -f 1 "${SEGM_BPE_MAP_SORTED}" >"${SEGM_VOCAB}"

# step 1: generate vocab & split into IV/OOV
# step 1.1: total vocab from sentences

echo "Finding total vocab from sentences..."
cat "${SENTENCES}" |
    subword-nmt get-vocab |
    cut -d' ' -f 1 |
    sort >"${VOCAB_TOT}"

echo "Finding IV types from sentences..."
# step 1.2: iv vocab from sentences

comm -12 "${VOCAB_TOT}" "${SEGM_VOCAB}" |
    sort >"${VOCAB_IV}"

echo "Finding OOV types from sentences..."
# step 1.3.: oov vocab from sentences
comm -23 "${VOCAB_TOT}" "${SEGM_VOCAB}" \
    >"${VOCAB_OOV}"

# step 2: apply seg_bpe_map to IV words -> segm file

echo "Applying MORSEL to IV types..."
join -1 1 -2 1 "${VOCAB_IV}" "${SEGM_BPE_MAP_SORTED}" \
    >"${VOCAB_IV}.segm"

# step 3: apply subword-nmt to OOV words -> segm file

echo "Apply BPE to OOV types..."
subword-nmt apply-bpe \
    --codes "${STEM_CODES}" \
    <"${VOCAB_OOV}" \
    >"${VOCAB_OOV}.segm-only"

paste -d " " "${VOCAB_OOV}" "${VOCAB_OOV}.segm-only" \
    >"${VOCAB_OOV}.segm"

echo "Union the segmentation files..."
# step 4: union the segmentation files
cat "${VOCAB_IV}.segm" "${VOCAB_OOV}.segm" >"${VOCAB_TOT}.segm"

# step 5: actually perform the lookups for each of the tokens
echo "Actually segmenting the sentences file..."
python "${PYTHON_SEGM_SCRIPT}" \
    --sentences "${SENTENCES}" \
    --segmentations "${VOCAB_TOT}.segm" \
    --output "${SENTENCES}.segm"

echo "All done!"

# ] <-- needed because of Argbash
